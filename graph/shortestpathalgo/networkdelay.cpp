class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<vector<pair<int,int>>> graph(n + 1);
        //hum graph ko adjacency list ki trh lete hai
        //taaki hum us node aur weight ko store kr le
        //hr node k liye uska padosi node aur ustk jaane ka smaya note krte hai

        // हम जो टाइम्स वाली लिस्ट है, उसमें हर एंट्री को एक-एक करके देख रहे हैं। हर एंट्री में बताया गया है कि कौन-सा नोड, किस नोड तक, कितने समय में जाता है। हम उस नोड के लिए उसकी adjacency list में उस पड़ोसी नोड और समय को जोड़ रहे हैं, ताकि ग्राफ तैयार हो जाए।
        for (auto &t : times) {
            graph[t[0]].push_back({t[1], t[2]});
        }

        //priority queue is liye liya hai taaki hm sbse km waale ko traverse kre aur use follopw kre taaki chota raasta mila

        priority_queue<pair<int,int>, 
                       vector<pair<int,int>>, 
                       greater<pair<int,int>>> pq;

        vector<int> dist(n + 1, INT_MAX);
        // हम यह जो distance वाला vector ले रहे हैं, वो हर नोड तक पहुंचने का minimum time track करने के लिए है। हम शुरुआत में सबको "अनंत" मानते हैं, यानी INT_MAX, क्योंकि हमें अभी पता नहीं कि कौन-सा रास्ता सबसे छोटा होगा। जब हमें रास्ते मिलते जाते हैं, हम उन्हें अपडेट करते जाते हैं।

        dist[k] = 0;
        pq.push({0, k});
        //यहाँ हम यह कह रहे हैं कि जो स्टार्टिंग नोड है, यानी k, वहाँ तक पहुंचने में समय तो जीरो ही है क्योंकि हम वहीं खड़े हैं। अब हम इस नोड को प्रायॉरिटी क्यू में डाल रहे हैं, ताकि वहीं से हम बाकी नोड्स की तरफ रास्ते ढूंढना शुरू कर सकें।



        // इस लूप में हम तब तक चलते हैं जब तक प्रायॉरिटी क्यू खाली नहीं हो जाती। हम हर बार प्रायॉरिटी क्यू से सबसे कम समय वाले (यानि सबसे नज़दीकी) नोड को निकालते हैं। अगर हम पहले ही उस नोड तक कम समय में पहुँच चुके हैं, तो उसे छोड़ देते हैं। नहीं तो उसके सभी पड़ोसी नोड्स को चेक करते हैं। अगर कोई नया छोटा रास्ता मिल जाए, तो हम उस पड़ोसी नोड की दूरी अपडेट करते हैं और उसे प्रायॉरिटी क्यू में डाल देते हैं ताकि आगे प्रोसेस हो सके।
        while (!pq.empty()) {
            auto [time, node] = pq.top();
            pq.pop();
            if (time > dist[node]) continue;
            // इस चेक का मतलब है कि अगर हम जिस नोड को अभी प्रायॉरिटी क्यू से निकाल रहे हैं, उससे पहले ही किसी छोटे समय में हम उस नोड तक पहुँच चुके हैं, तो आगे उसे प्रोसेस करने की ज़रूरत नहीं। हम उसे छोड़ देते हैं और लूप में आगे बढ़ते हैं। ये हमें पहले से ही मिले हुए छोटे रास्तों को प्रायॉरिटी देता है।


// यहाँ हम उस नोड के सभी जुड़े हुए पड़ोसियों को देख रहे हैं। हर पड़ोसी के लिए हम उसकी पहचान (कौन सा नोड है) और उस तक जाने का समय निकालते हैं। अब हम चेक करते हैं कि क्या हमें इस नए रास्ते से कम समय लग रहा है। अगर हाँ, तो हम उस पड़ोसी तक नया छोटा समय अपडेट करते हैं और उसे प्रायॉरिटी क्यू में डाल देते हैं, ताकि आगे प्रोसेस हो सके।
            for (auto &edge : graph[node]) {
                int neighbor = edge.first;
                int weight = edge.second;

                if (dist[neighbor] > time + weight) {
                    dist[neighbor] = time + weight;
                    pq.push({dist[neighbor], neighbor});
                }
            }
        }
        // अंत में हम चेक कर रहे हैं कि क्या कोई नोड ऐसा है जो कभी पहुँचा ही नहीं गया—यानि उसकी दूरी अभी भी अनंत है। अगर ऐसा है तो हम -1 लौटाते हैं, मतलब कोई रास्ता नहीं। अगर सब नोड तक पहुँचा जा चुका है, तो हम देखते हैं कि सबसे ज्यादा समय किस नोड तक पहुँचने में लगा और वही समय हम अंत में लौटाते हैं।

        int maxTime = 0;
        for (int i = 1; i <= n; i++) {
            if (dist[i] == INT_MAX) return -1;
            maxTime = max(maxTime, dist[i]);
        }

        return maxTime;
    }
};